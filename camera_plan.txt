
Plan for creating a camera for the videogame.

We want a first person camera. Unfortunately, OpenGL does not have the concept
of a camera. OpenGL only has a fixed viewport. Thus, to create camera-like
movement, OpenGL forces us to move the entire world. However, we want more
than just camera-like movement. We want to implement an high-level object
to act as a real-life camera. The camera should have a location, 
direction, focal length, near clipping distance, far clipping distance, and
a name. We should be able to switch between which cameras to render from at
will. The camera object will simply be a class to store and manipulate
the camera properties as variables.

To accomplish this, we first need a window with a gameloop to take in 
user keyboard and mouse input. Keyboard input must include special keys, and
mouse input must include buttons and the scroll wheel.

The main function will include the creation of a GameEngine object on the
stack. The GameEngine object will have a function called start() that will
initialize and start the game engine. If initialization fails, the start
function will print out an error message. The start function will be a void
function to make the main function as simple as possible.

PSEUDOCODE
main {
	GameEngine engine
	engine.start()
	return 0
}


The GameEngine object will need functions to initialize the window and
OpenGL. When initializing the Window, the object must also include a 
separate routine for establishing the openGL context to allow us to change
versions of OpenGL in the future. When initializing OpenGL, there needs to
be separate routines for initializing OpenGL settings and the initial scene
that will be loaded. In the future, the initial scene will be the title 
screne. Thus, scene loading must be separated from OpenGL settings loading.
The scene data will be stored in a Scene object.

PSEUDOCODE
// Define the GameEngine class
class GameEngine {
	private:
		glfwWindow window
		// pointer to a Scene object dynamically allocated
		Scene *scene
		// array holding the state of all keyboard keys (pressed/not pressed)
		bool *key
	public:
		// Constructor and deconstructor
		GameEngine()
		~GameEngine()
		void start();
		// These functions return integers signifying their success
		// Returning 0 means complete success, anything else is an error
		int initialize_window();
		int set_opengl_context();
		int initialize_opengl();
		int load_scene(filepath_to_directory_with_scene_data);
		void game_loop();
		int process_input();
		int update();
		void shutdown();
		void process_keyboard_input(window);
		// Handles mouse cursor position 
		void mouse_callback(window, double xpos, double ypos)
		// Handles mouse scroll wheel to zoom camera
		void scroll_callback(window, double xoffset, double yoffset);
}

// Loads the new scene and 
int load_scene (filepath_to_directory_of_new_scene) {
	// Load new scene
	Scene *new_scene = new Scene()
	new_scene.load_scene(filepath_to_directory_of_new_scene)
	// delete old scene and replace with new one
	delete scene
	scene = new_scene
}


// Define the Scene class
class Scene {
	private:
		// Pointer to an array of objects representing all objects in scene
		Object *objects
		
	public:
		// Constructors and deconstructors
		Scene()
		~Scene()
		// These functions return integers signifying their success
		// Returning 0 means complete success, anything else is an error
		int load_scene(filepath_to_directory_with_scene_data)
		int 
}
